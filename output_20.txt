TechMarket AI — Capítulo 17 Seguridad, Multi‑tenant, RLS, Auditoría, Compliance y Hardening (cero improvisación) Propósito del capítulo: establecer la base de seguridad “como en las grandes ligas” para un sistema multiempresa que maneja identidad, reputación, monetización, tickets y auditoría. Este capítulo define: multi‑tenant sólido, RLS en PostgreSQL, protección de datos, auditoría funcional, seguridad de API, hardening operativo y lineamientos mínimos de compliance. 17.1. Principio rector: multi‑tenant es un problema de seguridad, no de filtros Un error clásico es pensar: “solo filtro por tenant_id en queries”. Eso falla con: - bugs, - endpoints nuevos, - consultas complejas, - joins, - reportes. Principio enterprise: el aislamiento del tenant debe tener múltiples barreras : 1) IAM (authN/authZ) 2) App layer (tenant context) 3) DB layer (RLS) 4) Auditoría y detección 17.2. Identidad y acceso (IAM) — reglas de grandes ligas 17.2.1 Autenticación JWT con rotación de refresh tokens. sesiones cortas (access token). revocación (token blacklist) cuando sea necesario. 17.2.2 Autorización (RBAC/ABAC) roles globales (platform staff) roles por tenant (OWNER, SALES, TECH, etc.) permisos por recurso (opcional, fase 2) 17.2.3 Tenant context obligatorio Toda request que opera datos de negocio: - debe resolver tenant_id y branch_id . - nunca confiar en tenant_id enviado por el cliente. 17.3. Modelo multiempresa recomendado 17.3.1 Identificador del tenant tenant_id UUID. 17.3.2 Tenancy scopes datos globales (catálogo reference, taxonomías) datos por tenant (listings, staff, tickets) datos por sucursal (stock, agenda) 17.3.3 Rutas y seguridad endpoints públicos: catálogo/branches (filtrados por visibilidad) endpoints privados: /tenants/{id}/… Regla: el ID en la URL no define autorización; la autorización viene del token. 17.4. PostgreSQL RLS (Row Level Security) — implementación 17.4.1 Qué es RLS RLS permite que la base imponga políticas: aunque el desarrollador “olvide” el filtro, la DB bloquea. 17.4.2 Estrategia recomendada cada tabla “tenant‑owned” incluye tenant_id . habilitar RLS en tablas críticas. políticas que comparen tenant_id con un valor de sesión. 17.4.3 Tenant id en sesión (SET LOCAL) En cada request, al abrir transacción: - SET LOCAL app.tenant_id = '&lt;uuid&gt;' . Luego RLS usa current_setting('app.tenant_id') . 17.4.4 Ejemplo conceptual de política permitir SELECT/UPDATE/DELETE donde tenant_id = current_setting(...) . 17.4.5 Tablas que deben tener RLS tenant_staff_member catalog_listing ticket, quote, lead billing (subscription, invoice) ambassador attribution Regla: no activar RLS en tablas globales. 17.5. Concurrencia y consistencia (optimistic locking) TechMarket AI ya exige @Version. En seguridad, esto importa porque: - evita overwrites. - reduce race conditions. - protege operaciones críticas (payouts, billing, moderación). En recursos sensibles: - quote - payout - moderation_action - subscription Enterprise: idempotencia + optimistic locking. 17.6. Auditoría funcional (no solo logs) 17.6.1 Por qué auditoría funcional No basta con logs técnicos. Necesitas: - quién cambió estado de ticket - quién aprobó verificación - quién suspendió listing - quién aprobó payout 17.6.2 Modelo audit_log con: actor tenant scope action before/after reason traceId 17.6.3 Integración interceptores en capa application. eventos a outbox (Cap. 13). 17.7. Seguridad de API (OWASP, en práctica) 17.7.1 Rate limiting endpoints públicos: búsqueda/mapa endpoints sensibles: login, registro, tickets, reseñas 17.7.2 Protección de payload validation estricta (DTO) límites de tamaño sanitización de texto (XSS) 17.7.3 CORS y CSRF CORS estricto. CSRF si hay cookies; con JWT en header, menor riesgo pero igual atención. 17.7.4 Control de subida de archivos virus scan (fase 2) tipo y tamaño almacenamiento seguro 17.8. Seguridad de datos (PII) y privacidad 17.8.1 Datos sensibles teléfonos ubicaciones documentos KYB historial de tickets 17.8.2 Principios minimización: guardar lo necesario. encryption at rest (discos). encryption in transit (TLS). masking en logs. 17.8.3 Acceso interno platform staff ve solo lo necesario. evidencia con permisos. 17.9. Seguridad en MongoDB y almacenamiento 17.9.1 Colecciones sensibles docs de verificación evidencia de moderación 17.9.2 Controles separar DB por entorno. roles. TTL para logs temporales. 17.9.3 Objetos (S3/compatible) presigned URLs expiración antivirus en pipeline (fase 2) 17.10. Hardening operativo 17.10.1 Secret management no secrets en repos. vault/secret manager. 17.10.2 Entornos dev / staging / prod separados. datos anonimizados en staging. 17.10.3 Backups Postgres: backups diarios + PITR. Mongo: backups. pruebas de restore. 17.10.4 Access control infra SSH restringido. MFA. logs de acceso. 17.11. Seguridad para monetización 17.11.1 Idempotencia pagos y webhooks con idempotency key. 17.11.2 Webhooks firma/verificación. replay protection. almacenamiento de payload. 17.11.3 Ledger no editar entradas. solo reversos. 17.12. Compliance mínimo viable Sin entrar a marcos específicos, definimos: - retención de datos (política). - derecho a eliminación (cuando aplique). - términos para embajadores. - política de disputas. Enterprise: compliance no se improvisa al final. 17.13. Threat model (amenazas típicas) scraping masivo de catálogo. spam de reseñas. fraude de embajadores. ataque a pagos. acceso indebido cross‑tenant. Por cada amenaza: - mitigación (rate limit, RLS, antifraude, auditoría). 17.14. Implementación (paso a paso) Paso 1 — Tenant context middleware que resuelve tenant y setea contexto. Paso 2 — RLS políticas por tabla crítica. tests de aislamiento. Paso 3 — Auditoría audit_log + interceptores. Paso 4 — Hardening API rate limit validation file upload safe Paso 5 — Seguridad billing idempotencia webhooks firmados Paso 6 — Observabilidad tracing + alertas 17.15. Pruebas de seguridad (lo mínimo) pruebas de aislamiento cross‑tenant. pruebas de permisos por rol. pruebas de rate limit. pruebas de upload. pruebas de webhook replay. Definición de “listo” ningún usuario puede acceder datos de otro tenant. todas acciones críticas quedan auditadas. endpoints públicos resisten abuso básico. 17.16. Conexión con el Capítulo 18 Con seguridad establecida, el capítulo final amarra el cierre del proyecto: - Roadmap, fases, backlog épico, equipo, entregables y criterios de éxito. Fin del Capítulo 17
