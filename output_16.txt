TechMarket AI — Capítulo 13 Eventos, Mensajería, Jobs y Notificaciones (event‑driven para escalar sin caos) Propósito del capítulo: diseñar la “columna vertebral” operativa para que TechMarket AI escale con consistencia. Aquí definimos cómo fluyen los eventos, cómo se ejecutan jobs, cómo se mandan notificaciones y cómo garantizamos idempotencia, resiliencia y observabilidad. Este capítulo conecta casi todo: tickets (Cap. 8), CRM (Cap. 11), monetización (Cap. 12), embajadores (Cap. 9), reputación (Cap. 10) y búsqueda/ranking (Cap. 7). 13.1. Por qué event‑driven es clave en TechMarket AI Un sistema que integra: - leads, - tickets, - cotizaciones, - pagos, - comisiones, - reputación, - ranking, - notificaciones, no debe resolverse con “llamadas directas entre módulos” que generan acoplamiento y efectos colaterales. Si cada acción dispara 7 servicios de forma síncrona: - el sistema se vuelve frágil, - se vuelven comunes las inconsistencias, - el rendimiento cae. Principio enterprise: separar “escritura del evento” de “reacciones al evento”. 13.2. Enfoque recomendado: Outbox Pattern + Event Bus 13.2.1 Outbox Pattern Cuando ocurre algo (ej. ticket creado), en la misma transacción: 1) guardas el cambio (ticket) 2) guardas un evento en outbox_event Luego un dispatcher publica al bus. Beneficio: evita perder eventos si el sistema cae. 13.2.2 Event Bus Puede ser: - Kafka, - RabbitMQ, - o una cola managed. MVP pragmático: RabbitMQ o Kafka según infraestructura. 13.3. Tipos de eventos en TechMarket AI 13.3.1 Eventos de dominio (core) TenantCreated TenantVerified BranchUpdated 13.3.2 Eventos de catálogo ListingPublished ListingFlagged 13.3.3 Eventos de búsqueda/analytics ListingViewed WhatsAppClicked 13.3.4 Eventos de tickets TicketCreated TicketAssigned QuoteSent QuoteApproved TicketClosed 13.3.5 Eventos de CRM LeadCreated LeadStatusChanged 13.3.6 Eventos de monetización SubscriptionStarted PaymentCaptured PerformanceChargeCreated ChargeDisputed 13.3.7 Eventos de embajadores TenantAttributed CommissionCalculated PayoutCycleClosed 13.3.8 Eventos de reputación ReviewCreated ModerationActionTaken Regla: nombrar eventos en pasado, porque “ya ocurrió”. 13.4. Contratos de eventos (schema) y versionado 13.4.1 Campos mínimos Cada evento debe incluir: - eventId (UUID) - eventType - occurredAt - tenantId (si aplica) - actorUserId (si aplica) - payload - schemaVersion 13.4.2 Versionado nunca rompas consumidores. agrega campos de forma backward compatible. 13.4.3 Idempotencia Consumidores deben tratar eventos duplicados: - tabla consumed_event con eventId . 13.5. Notificaciones (multicanal) 13.5.1 Canales push (móvil) email WhatsApp (fase avanzada) in‑app inbox 13.5.2 Tipos de notificación ticket creado / asignado cotización enviada / aprobada recordatorio de cita lead sin respuesta pago exitoso / fallido payout listo 13.5.3 Plantillas plantillas versionadas. variables seguras. Principio: notificaciones deben ser consistentes y auditables. 13.6. Jobs (tareas programadas) necesarios 13.6.1 Jobs operacionales recalcular ranking por zona (batch) actualizar métricas diarias cerrar ciclos de payout aplicar follow‑ups 13.6.2 Jobs financieros reconciliación de pagos generación de invoices 13.6.3 Jobs antifraude scoring nocturno detección de patrones 13.7. Diseño de “scheduler” enterprise Opciones: - Spring Scheduler (simple) - Quartz (robusto) - workers dedicados Recomendación: - MVP: Spring Scheduler + locks distribuidos. - Escala: Quartz/worker. Regla: jobs deben ser idempotentes. 13.8. Observabilidad: logs, métricas y trazas 13.8.1 Logs estructurados incluir traceId , tenantId , eventId . 13.8.2 Métricas latencias de endpoints cola backlog tasa de errores en consumidores 13.8.3 Tracing OpenTelemetry. Enterprise: sin observabilidad, event-driven se vuelve “magia negra”. 13.9. Modelo de datos 13.9.1 PostgreSQL Tablas: - outbox_event - id , event_type , payload_json , status , created_at consumed_event consumer_name , event_id , consumed_at notification user_id , channel , template , payload , status job_lock job_name , locked_until , locked_by 13.9.2 MongoDB notification_templates webhook_payloads (auditoría) 13.9.3 Redis distributed locks rate limits 13.10. APIs GET /notifications/me POST /notifications/read Backoffice: - GET /backoffice/events/outbox - POST /backoffice/events/retry 13.11. Implementación (paso a paso) Paso 1 — Outbox crear tabla outbox. interceptor que escribe evento. Paso 2 — Dispatcher worker que publica al bus. Paso 3 — Consumers notificaciones métricas comisiones reputación Paso 4 — Idempotencia consumed_event. Paso 5 — Scheduler jobs críticos. locks. Paso 6 — Observabilidad trazas + métricas. 13.12. Pruebas y definición de “listo” Casos ticket creado genera evento y notificación. evento duplicado no duplica comisión. job de cierre de payout idempotente. Listo significa el sistema reacciona de forma consistente. no hay acoplamiento frágil. 13.13. Conexión con el Capítulo 14 Con eventos y métricas, ahora sí construimos el módulo de: - Analytics, dashboards, KPIs y decisiones (para negocio, embajador y plataforma). Fin del Capítulo 13
