TechMarket AI — Capítulo 7 Intent Search + IA (NLP/RAG) + Ranking Híbrido (búsqueda que entiende objetivos) Propósito del capítulo: construir el “cerebro” de TechMarket AI: un motor de búsqueda que entiende la intención humana y la traduce a resultados útiles y confiables. Esto une catálogo (Cap. 4), mapa (Cap. 3), compatibilidad (Cap. 5) y experiencia cliente (Cap. 6). El objetivo no es “buscar texto”, sino resolver una necesidad . 7.1. Por qué la búsqueda tradicional no sirve en este rubro En marketplaces tradicionales, el usuario escribe un producto exacto (“iPhone 14”). En electrónica/computación, muchas veces el usuario no sabe: - el nombre correcto del producto, - los requisitos técnicos, - los términos de compatibilidad. El usuario escribe: - “mi wifi no llega a mi cuarto”, - “quiero una pc gamer barata”, - “memoria para mi laptop”, - “router para casa grande”, - “mi laptop se calienta y se apaga”. Si el motor responde con resultados irrelevantes, pierde confianza. 7.2. Definición de Intent Search (en simple) Intent Search significa: 1) entender qué quiere lograr el usuario, 2) extraer restricciones (presupuesto, ubicación, categoría, dispositivo), 3) mapear a consultas estructuradas, 4) combinar keyword + filtros + vector search, 5) rankear por confianza y relevancia. Resultado: “lo que el usuario quiso decir”, no solo “lo que escribió”. 7.3. Entradas (inputs) del motor de búsqueda 7.3.1 Texto libre “pc gamer 4000 bs” “arreglar laptop pantalla rota” 7.3.2 Contexto de usuario ubicación (lat/lng) historial (favoritos, búsquedas) perfil (intereses) 7.3.3 Contexto del ecosistema disponibilidad por sucursal (stock) verificación y reputación performance (tiempo de respuesta) 7.3.4 Contexto de compatibilidad (si existe build) componentes ya seleccionados tipo de RAM, socket, etc. 7.4. Salidas (outputs) del motor La búsqueda no solo devuelve “resultados”, también devuelve: - categoría inferida (ej. redes vs reparación) - intención inferida (comprar vs reparar vs aprender) - filtros sugeridos (radio, verificado, rango de precio) - explicación breve (“te muestro talleres cercanos porque mencionaste ‘arreglar’”) - resultados (listings, negocios, servicios) 7.5. Taxonomía de intenciones (mínimo viable) 7.5.1 Intenciones de compra BUY_PRODUCT BUY_PART COMPARE 7.5.2 Intenciones de servicio REPAIR MAINTENANCE INSTALLATION DIAGNOSTIC 7.5.3 Intenciones de compatibilidad UPGRADE BUILD_PC CHECK_COMPAT 7.5.4 Intenciones de redes WIFI_COVERAGE NETWORK_SETUP CCTV_SETUP Recomendación: empezar con 12–20 intents claros; luego expandir. 7.6. Arquitectura del motor IA (capas) 7.6.1 Capa 1 — Normalización y detección de entidades Objetivo: limpiar el texto y detectar entidades: - marcas (Intel, AMD, TP-Link) - categorías (router, ram, reparación) - números (presupuesto, velocidad) - señales (“no enciende”, “pantalla azul”) Se hace con: - reglas + diccionarios (rápido y estable) - IA ligera para extraer entidades (cuando el texto es ambiguo) 7.6.2 Capa 2 — Clasificación de intención (Intent Classifier) Clasifica el texto en una intención. Opciones: - modelo ML clásico (SVM/logistic) con dataset curado. - LLM con prompt (MVP) con guardrails. Recomendación enterprise: empezar con LLM + validación; luego migrar a modelo propio para costos. 7.6.3 Capa 3 — Extracción de filtros (Slot Filling) Extrae: - presupuesto - ubicación/radio - tipo de dispositivo (laptop/pc/red) - categoría - preferencia “verificado” 7.6.4 Capa 4 — Ejecución de búsqueda híbrida Combina: - keyword (full‑text) - filtros estructurados - vector search (embeddings) 7.6.5 Capa 5 — Ranking híbrido Ordena por: - relevancia (intent match) - distancia - disponibilidad - confianza (verificado + métricas) - reputación - premium boost (moderado) 7.6.6 Capa 6 — Explicación y UI hints Genera: - chips de filtros sugeridos - explicación simple 7.7. RAG (Retrieval Augmented Generation) en TechMarket AI RAG no es “chatbot de Wikipedia”. Aquí RAG sirve para: - responder preguntas técnicas con base en catálogo y casos. - guiar al usuario (“para casa grande te conviene mesh”). - sugerir componentes compatibles. 7.7.1 Fuentes de conocimiento (controladas) catálogo reference (specs) documentos curados internos (guías) FAQ de tickets y resoluciones (anonimizadas) 7.7.2 Guardrails nunca inventar disponibilidad o precios. si no hay datos, decir “no tengo inventario confirmado”. separar “recomendación” de “hecho”. 7.8. Vector search (embeddings) — qué indexar Se recomienda indexar: 1) catalog_reference_item (title + specs) 2) catalog_listing (title + desc + atributos) 3) tenant_branch (perfil público + tags) 4) services (descripción de servicios) Objetivo: responder consultas ambiguas. 7.9. Ranking: fórmula base (MVP) 7.9.1 Score por candidato score = w1*intentMatch + w2*distance + w3*trust + w4*reputation + w5*availability + w6*premiumBoost 7.9.2 Ajustes por tipo Para “reparación”: trust y SLA pesan más. Para “compra”: precio/stock pesan más. Para “redes”: especialidad pesa más. 7.9.3 Reputación bayesiana Evita que 2 reseñas de 5 estrellas superen a 200 reseñas reales. 7.10. UI: cómo se ve Intent Search 7.10.1 Respuesta en pantalla categoría detectada: “Reparación” filtros sugeridos: “Verificados”, “&lt;5km”, “Abierto ahora” resultados: talleres cercanos + servicios 7.10.2 Preguntas de aclaración (solo si aporta) En vez de preguntar mucho, usar 1–2 preguntas: - “¿Es laptop o PC?” - “¿Cuál es tu presupuesto?” Regla: preguntar solo si mejora el ranking. 7.11. APIs del motor de búsqueda 7.11.1 Endpoint principal POST /search/intent Payload: - queryText - lat/lng - userContext (opcional) - buildId (opcional) Response: - intent - filtersSuggested - results (listings, branches, services) 7.11.2 Endpoint para autocompletado GET /search/suggest?q= 7.11.3 Endpoint para RAG Q&amp;A POST /assistant/qa 7.12. Implementación con Spring AI (enterprise) 7.12.1 Componentes IntentClassifierService EntityExtractorService SearchOrchestratorService RankingService RagAnswerService 7.12.2 Estrategia de prompts prompts cortos, estructurados. output en JSON validable. fallbacks a reglas. 7.12.3 Observabilidad loguear intención inferida. registrar “usuario corrigió intención” (feedback). medir CTR por intención. 7.13. Datos de entrenamiento (cómo se construyen sin gastar millones) 7.13.1 Bootstrapping dataset inicial con 500–2000 queries sintéticas (curadas por experto). luego reemplazar por queries reales anonimizadas. 7.13.2 Feedback cuando usuario selecciona un resultado, se confirma intención. si cambia filtros, se aprende. 7.14. Seguridad y costos 7.14.1 Evitar abuso rate limiting por IP. cache de resultados. throttling de embeddings. 7.14.2 Costos de LLM usar LLM solo en clasificación y extracción cuando hay ambigüedad. usar reglas y diccionarios en la mayoría. 7.15. Paso a paso (plan de obra) Paso 1 — Diccionarios y taxonomía categorías, marcas, intents. Paso 2 — Clasificador de intención LLM con output JSON. validación y fallback. Paso 3 — Híbrido: keyword + filtros + vector indexar embeddings. Paso 4 — Ranking fórmula base + ajustes por tipo. Paso 5 — UI chips sugeridos. explicación corta. Paso 6 — Feedback capturar confirmaciones. 7.16. Pruebas y definición de “listo” Casos de prueba “wifi no llega” → negocios integradores + productos mesh. “pc gamer 4000 bs” → listings + build suggestions. “pantalla laptop rota” → talleres + repuestos. Listo significa la búsqueda devuelve resultados útiles en 2–3 intentos. mejora CTR vs búsqueda textual. 7.17. Conexión con el Capítulo 8 El Intent Search genera demanda. Ahora hay que operarla con calidad: - Tickets, diagnóstico preliminar, SLAs, agenda y cotizaciones. Fin del Capítulo 7
