TechMarket AI — Capítulo 2 IAM, Multiempresa, Roles y Acceso (como se hace en las grandes ligas) Propósito del capítulo: dejar listo el “candado” del sistema antes de construir módulos de negocio. Si IAM está bien hecho, todo lo demás (catálogo, tickets, embajadores, reputación) se construye con seguridad, trazabilidad y escalabilidad. 2.1. Por qué IAM es el núcleo real del producto En TechMarket AI vamos a manejar: - Multiempresa (múltiples negocios y sucursales). - Usuarios de perfiles muy distintos (clientes, dueños, técnicos, vendedores, embajadores, moderadores, soporte interno). - Datos sensibles (teléfono/whatsapp, historial de tickets, reputación, pagos/comisiones, evidencias de reparaciones). Si no definimos desde el inicio quién puede ver qué , quién puede hacer qué y cómo se registra cada acción , el sistema queda frágil: filtraciones entre empresas, fraude en embajadores, manipulación de reputación, y soporte interno sin trazabilidad. Regla de oro (enterprise): todo request debe llegar con un contexto de identidad y empresa (tenant) bien definido, verificable y auditable. 2.2. Concepto de Multiempresa (Tenant) en TechMarket AI 2.2.1 ¿Qué es un tenant? Un tenant es la “empresa” o “negocio” dentro de TechMarket AI: una tienda, un taller técnico, un integrador de redes, etc. Cada tenant puede tener: - Sucursales (branch). - Usuarios internos (dueño, administradores, técnicos, vendedores). - Catálogo, tickets, agenda, leads, reputación, analítica . 2.2.2 Dos mundos de datos Mundo público (marketplace / discovery): información visible a usuarios clientes (perfiles, ubicación, reseñas públicas, productos/servicios publicados). Mundo privado del negocio: leads, tickets, cotizaciones, costos, evidencias internas, notas, métricas internas. Diseño clave: lo público puede cruzar tenants (porque el usuario descubre negocios), pero lo privado nunca . Esto se logra con dos capas: - Capa aplicación (validaciones en servicios). - Capa base de datos (Row-Level Security / RLS en PostgreSQL para aislamiento fuerte). 2.3. Personas y roles del sistema (quién entra y para qué) 2.3.1 Usuarios del lado Cliente Cliente / Usuario final: busca, compara, abre tickets, agenda servicios, deja reseñas. Cliente empresarial (opcional): solicita soporte (redes, servidores), requiere flujos de aprobación y facturación. 2.3.2 Usuarios del lado Negocio (Tenant) Owner (Propietario): dueño del tenant; administra sucursales, roles, pagos, premium. Admin de negocio: configuración general, catálogo, campañas. Manager de sucursal: operación del día a día (agenda, tickets, asignaciones). Técnico: atiende tickets, registra diagnóstico, evidencia, piezas usadas. Vendedor: cotiza, responde leads, registra órdenes. Cajero/Finanzas (si aplica): cobros, comisiones, facturación. 2.3.3 Usuarios del Programa Embajador Embajador: registra negocios y genera activaciones; ve su dashboard, cierres, payouts. Líder (nivel 2) / Mentor (nivel 3): mismos permisos que embajador, pero con vistas agregadas de su red (sin poder tocar datos privados de tenants). 2.3.4 Usuarios internos de TechMarket (Backoffice) Moderador: revisa publicaciones sospechosas, reportes, reputación. Soporte interno: resuelve incidencias, gestiona verificaciones. Auditor interno: solo lectura + export de logs. Super Admin: acceso restringido para mantenimiento (con doble control y auditoría). Nota didáctica: una “persona” no siempre equivale a un solo rol. Un mismo usuario puede ser cliente y además embajador, o cliente y owner de un negocio. 2.4. Estrategia de autenticación (login) “de grandes ligas” 2.4.1 Lo mínimo correcto Login por email o teléfono (WhatsApp) . Password hasheada con BCrypt/Argon2 (nunca texto plano). Refresh Token para sesiones largas (móvil) + Access Token corto. Protecciones anti‑brute force (rate limiting, lock temporal, captcha opcional). 2.4.2 Lo recomendable (enterprise) MFA (por OTP/Authenticator o WhatsApp/Email según contexto). Gestión de dispositivos (device fingerprint: “este teléfono es conocido”). Revocación de sesiones (logout real y “cerrar sesión en todos los dispositivos”). 2.4.3 ¿JWT o sesión server-side? Para TechMarket AI, la combinación más robusta es: - JWT Access Token (corto: 10–15 min) para performance. - Refresh Token almacenado (DB) para control real de sesiones. Esto evita el error común de “JWT eterno” que no se puede revocar bien. 2.5. Autorización: RBAC + reglas por contexto (ABAC ligera) 2.5.1 RBAC (Role Based Access Control) Se define un set de roles por tenant y roles globales. Ejemplos: - TENANT_OWNER , TENANT_ADMIN , BRANCH_MANAGER , TECHNICIAN , SALES , FINANCE . - AMBASSADOR , MODERATOR , SUPPORT , AUDITOR , SUPER_ADMIN . 2.5.2 ABAC ligera (reglas por atributos) RBAC solo no alcanza. Necesitamos reglas del tipo: - Un técnico puede ver solo tickets asignados a él o a su sucursal. - Un vendedor puede editar catálogo solo en su tenant . - Un embajador puede ver métricas de su red, pero nunca datos privados del tenant (leads, tickets). Estas reglas se implementan con: - Atributos en el token/contexto: tenantId , branchId , userId , scopes . - Validaciones en services (y, para lo crítico, también en DB con RLS). 2.6. Aislamiento de datos: cómo evitar fugas entre empresas 2.6.1 Patrón recomendado: Tenant Context obligatorio En cada request autenticado, el sistema debe resolver: - principal (usuario). - tenantContext (en qué empresa está operando). Caso típico: un usuario puede pertenecer a 2 negocios distintos. Entonces el front debe permitir “cambiar de empresa” y el backend debe validar que el usuario es miembro. 2.6.2 PostgreSQL con RLS (Row-Level Security) Idea: aunque un bug de aplicación ocurra, la BD igual protege. Estrategia: - Todas las tablas privadas del tenant incluyen tenant_id . - Se activa RLS y se crea policy del tipo: - “solo puedes leer filas cuyo tenant_id == current_setting(‘app.tenant_id’)”. En cada request: - El backend abre la transacción y hace SET LOCAL app.tenant_id = :tenantId . Esto es enterprise porque el aislamiento no depende solo del programador. 2.7. Flujos (lo que el usuario realmente hace) 2.7.1 Registro de Cliente Registro por email/teléfono. Verificación (OTP). Perfil básico (nombre, ciudad). Consentimientos mínimos (privacidad / comunicaciones). 2.7.2 Registro de Negocio (Owner) Owner crea cuenta. Crea tenant: nombre, categoría (tienda/taller/redes), ubicación principal. Crea sucursal principal. Sube documentos de verificación (opcional inicial, obligatorio para “Verificado”). Invita miembros (técnicos, vendedores) o los crea. 2.7.3 Invitación de usuarios al tenant (modelo empresa) El owner invita por email/teléfono. El invitado acepta, define contraseña, y entra con rol predefinido. 2.7.4 Login + selección de empresa Si el usuario pertenece a un solo tenant: entra directo. Si pertenece a varios: el front muestra selector y el backend valida pertenencia. 2.7.5 Embajador Registro embajador. Código/QR de atribución. Registro de negocio desde el flujo embajador. Cierre semanal: cálculo, antifraude, payout. 2.8. Modelo de datos (mínimo necesario) Este capítulo define el esqueleto; en el Capítulo 18 detallamos qué va en PostgreSQL/Mongo/Redis/Vector. 2.8.1 PostgreSQL (transaccional y crítico) Tablas recomendadas: - tenant (negocio) - tenant_branch (sucursales) - user_account - user_profile - tenant_membership (user ↔ tenant + rol + estado) - role / permission / role_permission (si haces RBAC configurable) - refresh_token (sesiones) - password_reset / otp_verification - audit_log (quién hizo qué) Optimistic locking (@Version): úsalo en entidades como tenant , user_account , role , tenant_branch y en operaciones críticas (para evitar sobrescrituras silenciosas). 2.8.2 MongoDB (documentos y evidencia) Colecciones típicas: - verification_documents (fotos, PDFs, estado de revisión) - kyc_reviews (historial de revisiones) - audit_evidence (adjuntos grandes y variabilidad) 2.8.3 Redis (performance y seguridad) Rate limiting: rl:login:{ip} OTP attempts: otp:tries:{user} Token blacklist (si necesitas invalidar access token antes de expirar) Cache de permisos: perm:{user}:{tenant} 2.9. Auditoría y trazabilidad (no negociable) 2.9.1 Qué se audita Login/logout/refresh. Cambios de rol. Cambios de membresías. Cambios de configuración del tenant. Acciones sensibles: verificación, payouts, moderación. 2.9.2 Cómo se audita Audit Log con: actor (userId) tenantId (si aplica) acción (enum) recurso (tipo + id) timestamp IP/device diff (antes/después) en acciones críticas Regla de oro: en disputas, el log debe permitir reconstruir la historia. 2.10. API de IAM (diseño recomendado) 2.10.1 Auth POST /auth/register POST /auth/verify-otp POST /auth/login POST /auth/refresh POST /auth/logout POST /auth/logout-all POST /auth/forgot-password POST /auth/reset-password 2.10.2 Tenants y membresías POST /tenants (crear negocio) POST /tenants/{tenantId}/branches POST /tenants/{tenantId}/invite-member PATCH /tenants/{tenantId}/members/{memberId} (cambiar rol/estado) GET /me/tenants (tenants a los que pertenezco) POST /me/switch-tenant (setear contexto) 2.10.3 Roles/Permisos GET /tenants/{tenantId}/roles POST /tenants/{tenantId}/roles (si RBAC configurable) Didáctico: aunque uses GraphQL en módulos de negocio, IAM es más simple y seguro en REST. 2.11. Implementación Spring Boot (paso a paso) Paso 1 — Fundamentos de seguridad Spring Security + configuración de filtros. PasswordEncoder (BCrypt/Argon2). UserDetailsService (o equivalente). Paso 2 — Emisión de tokens Crear TokenService : genera access token (JWT) con claims: sub , roles , tenantIds (o tenantId activo), branchId si aplica. genera refresh token (random seguro) y lo persiste. Paso 3 — Validación de tokens Filtro que: valida JWT arma SecurityContext extrae tenantId activo del header o del token (según estrategia) Paso 4 — Tenant Context + RLS TenantContextHolder (ThreadLocal) por request. En cada request que requiera tenant: validar membership setear SET LOCAL app.tenant_id = :tenantId (en el mismo transaction manager) Paso 5 — RBAC + reglas por servicio Anotaciones @PreAuthorize para roles. Validaciones por atributos (ABAC ligera) dentro de servicios. Paso 6 — Auditoría Interceptor/AOP o listeners para escribir audit_log . Paso 7 — Hardening Rate limiting (Redis). Bloqueo por intentos. Rotación y revocación de refresh tokens. 2.12. Pruebas: cómo demostrar que “el acceso está listo” 2.12.1 Checklist mínimo de pruebas Registro + OTP. Login correcto. Login incorrecto (rate limit). Refresh token. Logout + revocación. Cambio de contraseña. Invitación a tenant. Usuario sin membresía no puede operar tenant. Usuario multi‑tenant: switch seguro. RLS: probar que una query no puede leer otro tenant. 2.12.2 Herramientas Postman/Insomnia para smoke. Tests de integración con Testcontainers (PostgreSQL + Redis). Tests de seguridad: requests sin token, token expirado, token alterado. Definición de “listo”: si todas estas pruebas pasan, el backend está preparado para construir módulos sin miedo. 2.13. Entregables de este capítulo (lo que debe quedar hecho) Modelo de roles/personas aprobado. Endpoints de auth operativos. Membership y switch de tenant. RLS activo en tablas privadas. Auditoría mínima. Suite de smoke tests y/o integración. 2.14. Cómo conecta con el Capítulo 3 Una vez IAM está listo, el siguiente paso natural es: - Negocios, sucursales, verificación y geolocalización (mapa, categorías, señales de confianza), porque esos objetos necesitan tenant + roles + auditoría para operar bien. Fin del Capítulo 2
