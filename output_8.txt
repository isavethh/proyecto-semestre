TechMarket AI — Capítulo 5 Motor de Compatibilidad (PC Builder + Reglas + Dataset + Feedback Loop) Propósito del capítulo: construir el diferenciador más fuerte de TechMarket AI: un motor que reduzca errores de compra/upgrade y mejore conversión, reputación y soporte. El motor de compatibilidad se apoya en el catálogo estructurado del Capítulo 4 y alimenta directamente búsqueda por intención, recomendaciones, tickets y la “carpeta técnica” del equipo. 5.1. Qué problema resuelve (y por qué es un “moat”) En computación, la compatibilidad no es “opcional”: es el filtro que separa una compra exitosa de una pérdida de tiempo y dinero. La mayoría de plataformas generalistas no resuelve: - socket/chipset/BIOS, - límites de RAM (tipo, frecuencia, perfiles, cantidad de módulos), - consumo eléctrico y conectores, - dimensiones (GPU/case/cooler), - líneas PCIe y cuellos de botella, - compatibilidad de almacenamiento (NVMe/PCIe Gen), - restricciones por factor de forma. Moat real: no es el UI del “armador de PC”, sino el dataset y el feedback loop con tickets reales. 5.2. Alcance inicial (MVP) y expansión 5.2.1 MVP (compatibilidad útil, no perfecta) Se recomienda empezar con un núcleo sólido: - CPU ↔ Motherboard (socket + chipset + generación) - RAM ↔ Motherboard (tipo DDR + slots + límite) - GPU ↔ Case (largo + ancho + slots) - PSU ↔ GPU/CPU (watts + conectores) - Storage ↔ Motherboard (M.2/SATA + gen) - Cooler ↔ Case ↔ CPU (altura + socket) 5.2.2 Fase 2 (refinamiento) compatibilidad BIOS por versión. QVL parcial (listas de memorias compatibles). performance estimada por escenario (gaming/creación). 5.2.3 Fase 3 (ecosistema completo) laptops (compatibilidad de repuestos por modelo exacto). redes (compatibilidad de estándares, cobertura, topología). 5.3. Diseño conceptual: “Build” como agregado de dominio La compatibilidad se modela mejor como un agregado : 5.3.1 Entidad Build Un Build representa una configuración: - propósito (gaming, oficina, streaming, redes), - presupuesto, - componentes seleccionados, - validaciones y alertas, - estado (draft, compartido, convertido en compra, convertido en ticket). 5.3.2 Por qué es importante permite guardar historial, permite compartir con un técnico, permite usarlo como entrada para cotización, permite generar recomendaciones. 5.4. Modelo de reglas: de “hard constraints” a “soft constraints” 5.4.1 Hard constraints (no se puede) socket incompatible. RAM DDR5 en board DDR4. case ITX con motherboard ATX. PSU sin conector requerido. Resultado: bloquea o alerta crítica. 5.4.2 Soft constraints (se puede pero no conviene) PSU “justa” sin margen. GPU muy potente con CPU que hace bottleneck. RAM por debajo de lo recomendado para el objetivo. Resultado: recomendaciones. 5.4.3 Heurísticas En MVP, muchas decisiones son heurísticas: - margen PSU (ej. 25–35% por encima del consumo estimado). - recomendación RAM mínima por uso. - límites térmicos aproximados. Regla didáctica: no prometer “exactitud absoluta”; prometer “reducción significativa de errores”. 5.5. Data model: qué atributos son obligatorios El motor depende de atributos en el catálogo (reference items). Campos mínimos por categoría: CPU socket generación (o family) TDP performance tier (básico: low/mid/high) Motherboard socket chipset form factor RAM type (DDR4/DDR5) RAM slots max RAM M.2 slots + gen (si posible) RAM DDR type freq kit size total GB GPU length_mm slots power_w power_connectors (8pin, 12VHPWR) PSU watt certification connectors Case form_factor_supported max_gpu_length max_cooler_height Storage interface (SATA/NVMe) gen (PCIe 3/4/5) Conclusión: si el catálogo no tiene estos atributos, la compatibilidad no puede ser seria. 5.6. Arquitectura del motor: “Compatibility Service” modular 5.6.1 Componentes internos Catalog Adapter: obtiene reference specs. Rule Engine: evalúa reglas. Estimator: calcula consumo y recomendaciones. Explanation Builder: genera explicación humana (“por qué”). Feedback Collector: registra outcomes. 5.6.2 Modos de uso Modo interactivo (UI PC Builder): valida en tiempo real. Modo batch: validar catálogo o publicaciones. Modo ticket: validar compatibilidad con el caso del usuario. 5.6.3 Principio enterprise Separar: - reglas “core” (inmutables y testeadas) - reglas “configurables” (ajustables por región/política) 5.7. Algoritmo base (MVP) — flujo de validación el usuario selecciona componentes. el motor arma la lista de specs. ejecuta validaciones hard. calcula consumo estimado. ejecuta recomendaciones soft. genera resultado: COMPATIBLE / COMPATIBLE_WITH_WARNINGS / INCOMPATIBLE lista de issues con severidad recomendaciones y alternativas. 5.8. “Explainability”: el porqué es parte del producto La compatibilidad debe explicar con lenguaje simple: - qué atributo chocó, - qué valor se esperaba, - cómo resolverlo. Ejemplo: - “Tu motherboard es DDR4. La memoria que elegiste es DDR5. Debes cambiar la RAM a DDR4 o elegir una motherboard DDR5”. Esto reduce soporte y aumenta confianza. 5.9. Integración con el catálogo (Capítulo 4) 5.9.1 Reference-first El motor trabaja sobre catalog_reference_item (plantilla). Si un listing no está linkeado a referencia: - el motor intenta inferir atributos (IA) y marca “confidence score”. 5.9.2 Control de calidad El motor se usa para: - detectar listings incoherentes, - sugerir correcciones, - reducir fraude. 5.10. UX: PC Builder en app cliente 5.10.1 Flujos principales “Armar PC desde cero” “Mejorar mi PC” (ingresar componentes actuales) “Quiero X con presupuesto Y” (intención) 5.10.2 UI recomendada Selector por componente con búsqueda. Panel de compatibilidad siempre visible. Alertas por severidad. Botón “ver alternativas” (listings disponibles cerca). 5.10.3 Conversión Una vez compatible: - mostrar negocios cercanos con stock/precio. - permitir “cotizar” o “abrir ticket” para armado. 5.11. API del motor de compatibilidad 5.11.1 Endpoints recomendados POST /compat/builds (crear build) PATCH /compat/builds/{id} (agregar/quitar componente) POST /compat/builds/{id}/validate GET /compat/builds/{id} POST /compat/builds/{id}/recommendations 5.11.2 Payload base Incluye: - lista de reference_item_id por categoría - objetivo (intent) - presupuesto - región/ciudad 5.12. Modelo de datos (persistencia) 5.12.1 PostgreSQL compat_build id , user_id , status , purpose , budget , created_at , version compat_build_item build_id , category , reference_item_id , qty compat_validation_result build_id , status , issues_json , score , created_at 5.12.2 MongoDB compat_explanations (texto largo + variantes) compat_feedback (casos reales, outcomes) 5.12.3 Vector store embeddings de issues/recommendations para mejorar explicación y triage. 5.13. Feedback Loop: cómo el sistema aprende Sin feedback, el motor se estanca. En TechMarket AI el feedback viene de: - tickets de armado/reparación, - devoluciones, - reseñas, - correcciones de técnicos verificados. 5.13.1 Eventos clave build creado build validado build convertido en compra/cotización issue reportado compatibilidad confirmada/rechazada por técnico 5.13.2 Cómo usar feedback ajustar heurísticas (margen PSU, recomendaciones RAM) detectar reglas faltantes curar reference items 5.14. Seguridad y antifraude El motor puede ser manipulado si: - se crean reference falsos, - se publican listings con atributos engañosos. Medidas: - reference items curados (o con score). - cambios auditados. - restricciones por rol para editar specs. 5.15. Implementación paso a paso (plan de obra) Paso 1 — Definir atributos y completar reference items crear schema de atributos por categoría. poblar reference items top 200 (CPU/MB/RAM/GPU/PSU/case). Paso 2 — Implementar Rule Engine reglas hard core (socket, DDR, form factor). reglas de dimensiones. reglas de conectores. Paso 3 — Implementar Estimator consumo aproximado CPU+GPU+extras. recomendación PSU. Paso 4 — Explainability templates por regla. severidad. Paso 5 — UI PC Builder flujo interactivo. guardado de build. Paso 6 — Recomendaciones alternativas disponibles por zona. ranking por confianza + precio + distancia. Paso 7 — Feedback eventos + almacenamiento. 5.16. Pruebas esenciales y definición de “listo” 5.16.1 Casos de prueba CPU incompatible con board → INCOMPATIBLE. RAM DDR5 en DDR4 → INCOMPATIBLE. GPU más larga que case → warning/blocked. PSU insuficiente → warning crítico. build compatible → recomendaciones. 5.16.2 “Listo” significa reduce compras erróneas, genera explicaciones claras, integra catálogo y mapa para convertir. 5.17. Conexión con el Capítulo 6 El motor de compatibilidad alimenta el discovery. El siguiente capítulo construye: - App cliente: discovery, mapa, filtros, ranking, favoritos y conversiones. Fin del Capítulo 5
